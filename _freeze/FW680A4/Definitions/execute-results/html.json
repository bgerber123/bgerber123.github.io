{
  "hash": "38865dca9cd87588a9919ff8aa2a3f50",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Coding and Mathematical Definitions\"\nauthor: \"Brian D. Gerber\"\ndate: \"December 10, 2024\"\noutput: pdf_document\nheader-includes:\n   - \\usepackage{calc,amsmath,tikz}\n   - \\usetikzlibrary{matrix,calc}\n---\n\n\n\n\n\n\n\\vspace{12pt}\n\\begin{center}\\textbf{\\LARGE Definitions of R Code} \\end{center}\n\\vspace{12pt}\n\n\\textbf{\\large R script}\n\nthe lines of code and comments that you are writing (filename.R).  \n\\vspace{12pt}\n\n\\textbf{\\large R project}\n\nyour R script, any variables you have created, and your current R environment (filename.Rproj).  \n\\vspace{12pt}\n\n\\textbf{\\large R package}\n\na set of functions/code that you can load into your script (examples - dplyr, sp).  \n\\vspace{12pt}\n\n\\textbf{\\large R Comment}: does not run as code, starts with #. You use comments to explain what your code is doing in plain langauge.  \n\\vspace{12pt}\n\n\\textbf{\\large Object or Variable}\n\na unit of information that is stored in the workspace (computer memory) and can be recalled or manipulated. 'a' is an object. Specifically, a vector of length 3.  \n\n\n\n\n\n```{.r .cell-code}\na = c(3, 2, 1)\n```\n\n\n\n\\ \\\n\\textbf{\\large Element}\n\na piece of information within an object. The 1st element of a is...\n\n\n\n\n\n```{.r .cell-code}\na[1]\n```\n\n[1] 3\n\n\n\n\\ \\\n\\vspace{12pt}\n\n\\textbf{\\large Function}\n\na command to take inputs (objects or elements) and manipulates it to provide an output, which can be saved as a new object.\n\n\n\n\n```{.r .cell-code}\nfun.text = function(x) {\n    paste(\"Your input variable is \", x, sep = \"\")\n}\n\nfun.text(4)\n```\n\n[1] \"Your input variable is 4\"\n\n```{.r .cell-code}\nfun.text(\"INPUT\")\n```\n\n[1] \"Your input variable is INPUT\"\n\n\n\n\\ \\\n\\vspace{12pt}\n\n\\textbf{\\large Argument}\n\na specific command within a function. Many functional arguments are preset and do not need to be explitly stated.\n\n\n\n\n\n```{.r .cell-code}\nx = c(1, 2, 3, NA)\nmean(x)\n```\n\n[1] NA\n\n```{.r .cell-code}\n# na.rm is an argument of the function mean to ignore the missing value. Its\n# preset is FALSE. If you have na's you need to change the argument to 'TRUE'.\nmean(x, na.rm = TRUE)\n```\n\n[1] 2\n\n\n\n\n\\vspace{12pt}\n\n\n\n\\begin{center}\\textbf{\\LARGE Types of R Objects and Mathematical Notation} \\end{center}\n\\vspace{12pt}\n\n\\textbf{\\large Vector}\n\n1 row, many columns OR 1 column many rows. Can be numbers of characters.\n\n\n\n\n\n```{.r .cell-code}\nv = c(4, 1, 3)\nis.vector(v)\n```\n\n[1] TRUE\n\n```{.r .cell-code}\nlength(v)\n```\n\n[1] 3\n\n\n\n\nMath notation (capitalized & lower case):\n$\\vec{v}$ \\ or \\ $\\textbf{v}$\n\n\\ \\\n\n\\begin{align}\n  \\textbf{v} &= \\begin{bmatrix}\n           4 &\n           1 &\n           3\n\\end{bmatrix}\n\\end{align}\n\n\\vspace{12pt}\n\n\\textbf{\\large Matrix}\n\nGeneralization of vectors. Can have 1 or more rows and columns. Only numbers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM = matrix(1:10, nrow = 2)\nM\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 5\n```\n\n\n:::\n\n```{.r .cell-code}\nis.vector(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.matrix(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nMath notation (capitalized & upper case):\n$\\textbf{M}$\n\n\\ \\\n\n\\begin{align}\n  \\textbf{M} &= \\begin{bmatrix}\n           1 & 3 & 5 & 7 & 9 \\\\\n           2 & 4 & 6 & 8 & 10\n\\end{bmatrix}\n\\end{align}\n\n\\ \\\n\n\\vspace{12pt}\n\n\\textbf{\\large Array}\n\nGeneralization of matrices. Can be n dimensional. Only numbers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\narr = array(1:100, dim = c(3, 4, 3))\narr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   13   16   19   22\n[2,]   14   17   20   23\n[3,]   15   18   21   24\n\n, , 3\n\n     [,1] [,2] [,3] [,4]\n[1,]   25   28   31   34\n[2,]   26   29   32   35\n[3,]   27   30   33   36\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 3\n```\n\n\n:::\n\n```{.r .cell-code}\nis.vector(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.matrix(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.array(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\\begin{tikzpicture}[every node/.style={anchor=north east,fill=white,minimum width=1.4cm,minimum height=7mm}]\n\\matrix (mA) [draw,matrix of math nodes]\n{\n25 & 28 & 31 & 34 \\\\\n26 & 29 & 32 & 35 \\\\\n27 & 30 & 33 & 36 \\\\\n};\n\n\\matrix (mB) [draw,matrix of math nodes] at ($(mA.south west)+(1.5,0.7)$)\n{\n13 & 16 & 19 & 22 \\\\\n14 & 17 & 20 & 23 \\\\\n15 & 18 & 21 & 24 \\\\\n \\\\\n};\n\n\\matrix (mC) [draw,matrix of math nodes] at ($(mB.south west)+(1.5,0.7)$)\n{\n1 & 4 & 7 & 10 \\\\\n2 & 5 & 8 & 11 \\\\\n3 & 6 & 9 & 12 \\\\\n};\n\n\\draw[dashed](mA.north east)--(mC.north east);\n\\draw[dashed](mA.north west)--(mC.north west);\n\\draw[dashed](mA.south east)--(mC.south east);\n\\end{tikzpicture}\n\n\n\\ \\\n\n\\vspace{12pt}\n\n\\textbf{\\large List}\n\nCan store any type of objects together.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist1 = vector(\"list\", 2)\nlist1[[1]] = v\nlist1[[2]] = M\nlist1[[3]] = arr\n\nis.list(list1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(list1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nlist1[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 1 3\n```\n\n\n:::\n:::\n\n\n\n\n\\vspace{12pt}\n\n\\begin{center}\\textbf{\\LARGE Important Functions} \\end{center}\n\n\\textbf{\\large For Loop} \n\nTo do a task many times. Simple, but inefficient\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#First, create a large matrix\nx <- matrix(rnorm(400*4000), ncol=400)\n\n#Second, create a vector to store results\nmx <- rep(NA, nrow(x))\n\n#Third, for each row of the matrix, find the maximum value and store it in mx using \n#a loop. We will do this from index 1 to the max number of rows (nrow(x)). We will \n#iterate using index i.\n\nfor(i in 1:nrow(x)){\n  mx[i] <- max(x[i,])\n}\n```\n:::\n\n\n\n\n\\vspace{12pt}\n\n\\textbf{\\large ifelse}\n\nused to return an output based on specified conditions\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Syntax:\nIf (test_expression) {\n  Statement \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example:\na = c(5,7,2,9)\nifelse(a %% 2 == 0,\"even\",\"odd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"odd\"  \"odd\"  \"even\" \"odd\" \n```\n\n\n:::\n\n```{.r .cell-code}\n#OR\n\nx <- 5\nif(x > 0){\n  print(\"Positive number\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Positive number\"\n```\n\n\n:::\n:::\n\n\n\n\n\\vspace{12pt}\n\n\\textbf{\\large apply} \n\nTo do a task many times using vectorization. Much faster then a for loop.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(rnorm(400*4000), ncol=400)\n\n# The 1 indicates to the function 'max' on the rows of the object 'x'. A 2 would \n# make this function should be applied to each column of the object 'x'.\nmx2 <- apply(x, 1, max)\n```\n:::\n\n\n\n\nAnother Example\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndataTable <- cbind(x1 = 1, x2 = (c(4:0, 2:6)))\ndataTable\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      x1 x2\n [1,]  1  4\n [2,]  1  3\n [3,]  1  2\n [4,]  1  1\n [5,]  1  0\n [6,]  1  2\n [7,]  1  3\n [8,]  1  4\n [9,]  1  5\n[10,]  1  6\n```\n\n\n:::\n\n```{.r .cell-code}\n# Sum each of the rows of the data table\napply(dataTable, MARGIN = 1, FUN = sum)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 5 4 3 2 1 3 4 5 6 7\n```\n\n\n:::\n\n```{.r .cell-code}\n# Now sum the columns\napply(dataTable, MARGIN = 2, FUN = sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx1 x2 \n10 30 \n```\n\n\n:::\n:::\n\n\n\n\n\\vspace{12pt}\n\n\\textbf{\\large lapply}\n\nTo do a task many times using vectorization for each list element.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist1 <- list(1:20, 1:5, 1:100)\nlistOutput <- lapply(list1, FUN = quantile, probs = c(0.025, 0.975))\nlistOutput\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n  2.5%  97.5% \n 1.475 19.525 \n\n[[2]]\n 2.5% 97.5% \n  1.1   4.9 \n\n[[3]]\n  2.5%  97.5% \n 3.475 97.525 \n```\n\n\n:::\n\n```{.r .cell-code}\nis.list(listOutput) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\\textbf{\\large sapply} \n\ntakes lists, vectors or data frames as input and gives output in vector or matrix.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlistOutput2 <- sapply(list1, FUN = quantile, probs = c(0.025, 0.975))\nlistOutput2 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        [,1] [,2]   [,3]\n2.5%   1.475  1.1  3.475\n97.5% 19.525  4.9 97.525\n```\n\n\n:::\n\n```{.r .cell-code}\nis.list(listOutput2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.matrix(listOutput2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\\vspace{12pt}\n\n\\textbf{\\large mapply}\n\nallows you to apply a function to elements of a matrix.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(a = c(1:10), b = c(11:20))\nl2 <- list(c = c(80:89), d = c(90:99))\n\n# sum the corresponding elements of l1 and l2\nmapply(sum, l1$a, l1$b, l2$c, l2$d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 182 186 190 194 198 202 206 210 214 218\n```\n\n\n:::\n:::\n\n\n\n\n\\vspace{12pt}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}