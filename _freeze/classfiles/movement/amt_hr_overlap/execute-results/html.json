{
  "hash": "bb365a9db81b612ee350ac0147547bcb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Calculating home-range overlaps with `amt`\"\nauthor: \"Johannes Signer and John Fieberg\"\ndate: \"2024-10-17\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteKeyword{hr-overlap}\n  %\\VignetteIndexEntry{Calculating home-range overlaps with `amt`}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n\n\n\n## Background\n\nSeveral different indices have been proposed for measuring home-range overlap. These are reviewed\nby Fieberg & Kochanny\n(2005).\nThere are two general approaches used to calculate home-range overlap: 1) calculate the percentage overlap at a given isopleth level (this works for geometric and probabilistic home ranges) or 2) calculate an index of\nsimilarity between the two utilization distributions (UD; this only works for\nprobabilistic estimators)^[For a discussion of geometric vs. probabilistic estimators see here: https://www.biorxiv.org/content/10.1101/2020.08.19.256859v2].\n\n## Implementation in `amt`\n\n`amt` currently implements all methods to calculate overlaps that were reviewed by Fieberg and Kochany (2005). These are: \n\n- `hr`: That is the proportion of the home range of instance $i$ that overlaps with the home range of instance $j$. This measure does not rely on a UD and is directional (i.e., $HR_{i,j} \\ne HR_{j,i}$) and bound between 0 (no overlap) and 1 (complete overlap)\n- `phr`: Is the probability of instance $j$ being located in the home range of instance $i$. `phr` is also directional and bounded between 0 (no overlap) and 1 (complete overlap)\n- `vi`: The volumetric intersection between two UDs.\n- `ba`: The Bhattacharyya's affinity between two UDs. \n- `udoi`: A UD overlap index. \n- `hd`: Hellinger's distance between two UDs. \n\nThese overlap indices can be calculated with the function `hr_overlap`. The type of overlap measure an be controlled with the argument `type`. \n\nAll of these estimators can be calculated for a given home-range level (i.e., using conditional UDs). Whether or not a conditional overlap is desired or not, can be controlled with the argument `conditional`. For `hr`, the argument `conditional` has no effect and the isopleths used for home-range estimation will always be used for the overlap calculation. \n\nThe function `hr_overlap()` can also be provided with a list of home-range estimates in situations when overlap between many different instances are required. Currently, there are three options for calculating overlap among multiple instances: `which = \"all\"` calculates overlap for each pair of home ranges, `which = \"one_to_all\"` calculates overlap between the first element in the list and all others, and `which = \"consecutive\"` will calculate overlap between consecutive elements in the list. \n\n\n## Examples\n\nFirst we need to load the required packages: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(amt)\nlibrary(ggplot2)\nlibrary(tidygraph)\nlibrary(ggraph)\n```\n:::\n\n\n\n\n### Two instances\n\nWe will use tracking data from Fishers from New York State, USA. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleroy <- amt_fisher |> filter(name == \"Leroy\")\nlupe <- amt_fisher |> filter(name == \"Lupe\")\n```\n:::\n\n\n\n\nCreate a template raster for the KDE\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrast <- make_trast(amt_fisher |> filter(name %in% c(\"Leroy\", \"Lupe\")), res = 50)\n```\n:::\n\n\n\n\nAnd estimate home-ranges for both fishers\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_leroy <- hr_kde(leroy, trast = trast, levels = c(0.5, 0.9))\nhr_lupe <- hr_kde(lupe, trast = trast, levels = c(0.5, 0.9))\n```\n:::\n\n\n\n\n`hr` and `phr` are directional, this means the order matters. For all other overlap measures the order does not matter. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_overlap(hr_leroy, hr_lupe, type = \"hr\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  levels overlap\n   <dbl>   <dbl>\n1    0.9   0.309\n2    0.5   0.191\n```\n\n\n:::\n\n```{.r .cell-code}\nhr_overlap(hr_lupe, hr_leroy, type = \"hr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  levels overlap\n   <dbl>   <dbl>\n1    0.9   0.986\n2    0.5   0.574\n```\n\n\n:::\n:::\n\n\n\n\nBy default `conditional = FALSE` and the full UD is used.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_overlap(hr_leroy, hr_lupe, type = \"phr\", conditional = FALSE) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  levels overlap\n   <dbl>   <dbl>\n1      1       1\n```\n\n\n:::\n\n```{.r .cell-code}\nhr_overlap(hr_lupe, hr_leroy, type = \"phr\", conditional = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  levels overlap\n   <dbl>   <dbl>\n1      1   0.736\n```\n\n\n:::\n:::\n\n\n\n\nIf we set `conditional = TRUE`, the overlap is measured at home-range levels that were specified during estimation. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_overlap(hr_leroy, hr_lupe, type = \"phr\", conditional = TRUE) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  levels overlap\n   <dbl>   <dbl>\n1    0.5   0.580\n2    0.9   0.992\n```\n\n\n:::\n\n```{.r .cell-code}\nhr_overlap(hr_lupe, hr_leroy, type = \"phr\", conditional = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  levels overlap\n   <dbl>   <dbl>\n1    0.5   0.221\n2    0.9   0.401\n```\n\n\n:::\n:::\n\n\n\n\nNote, for the remaining overlap measures the order does not matter. Below\nwe show this for the volumnic intersection (`type = \"vi\"`) as an example. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_overlap(hr_lupe, hr_leroy, type = \"vi\", conditional = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  levels overlap\n   <dbl>   <dbl>\n1      1   0.439\n```\n\n\n:::\n\n```{.r .cell-code}\nhr_overlap(hr_leroy, hr_lupe, type = \"vi\", conditional = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  levels overlap\n   <dbl>   <dbl>\n1      1   0.439\n```\n\n\n:::\n:::\n\n\n\n\n### $> 2$ instances\n\nLets calculate daily ranges for Lupe and then and then see how different\nranges overlap with each other.\n\nWe have to use the same template raster in order to make ranges comparable. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrast <- make_trast(lupe, res = 50)\n```\n:::\n\n\n\n\nThen we add a new column with day and calculate for each day a `KDE` home range. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- lupe |> \n  mutate(week = lubridate::floor_date(t_, \"week\")) |> \n  nest(data = -week) |> \n  mutate(kde = map(data, hr_kde, trast = trast, levels = c(0.5, 0.95, 0.99)))\n```\n:::\n\n\n\n  \nNow we can use the list column with the home-range estimates to calculate\noverlap between the different home-ranges. By default `which = \"consecutive\"`, this means for each list entry (= home-range estimate) the overlap to the next entry will be calculated.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_overlap(dat$kde, type = \"vi\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n   from    to levels overlap\n  <int> <int>  <dbl>   <dbl>\n1     1     2      1  0.0431\n2     2     3      1  0.551 \n3     3     4      1  0.612 \n```\n\n\n:::\n:::\n\n\n\n\nThis works as well, if we set `conditional = TRUE`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_overlap(dat$kde, type = \"vi\", conditional = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 4\n   from    to levels overlap\n  <int> <int>  <dbl>   <dbl>\n1     1     2   0.5   0     \n2     1     2   0.95  0.0264\n3     1     2   0.99  0.0357\n4     2     3   0.5   0.264 \n5     2     3   0.95  0.528 \n6     2     3   0.99  0.547 \n7     3     4   0.5   0.318 \n8     3     4   0.95  0.592 \n9     3     4   0.99  0.608 \n```\n\n\n:::\n:::\n\n\n\n\nSometimes it can be useful to provide meaningful labels. We can do this with\nthe `labels` argument.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_overlap(dat$kde, type = \"vi\", labels = dat$week)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  from       to         levels overlap\n  <chr>      <chr>       <dbl>   <dbl>\n1 2010-12-12 2010-12-19      1  0.0431\n2 2010-12-19 2010-12-26      1  0.551 \n3 2010-12-26 2011-01-02      1  0.612 \n```\n\n\n:::\n:::\n\n\n\n\nDifferent options exist for the argument `which`. For example, `which = \"one_to_all\"` calculates the overlap between the first and all other home ranges. \n\n<!--\nFinally, we can calculate the overlap between all elements inside a list (use\n`which = \"all\"` for this). We will use the `puechcir` from the `adehabitatLT` package to illustrate this. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"puechabon\", package = \"adehabitatLT\")\ndat <- puechabonsp$relocs |> as.data.frame() |> \n  make_track(X, Y, id = Name)\ntrast <- make_trast(dat, res = 50)\ndat1 <- dat |> nest(data = -id) |> \n  mutate(kde = map(data, ~ hr_kde(., trast = trast, level = c(0.5, 0.9, 0.99))))\n```\n:::\n\n\n\n\nNow we can calculate the overlaps between animals: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nov2 <- hr_overlap(dat1$kde, type = \"hr\", labels = dat1$id, which = \"all\", \n                  conditional = TRUE) |> \n  filter(overlap > 0)\ngraph <- as_tbl_graph(ov2) |> \n  mutate(Popularity = centrality_degree(mode = 'in')) \n\nggraph(graph, layout = 'stress') + \n  #geom_edge_fan(aes(col = overlap), show.legend = TRUE, arrow = arrow()) + \n  geom_edge_arc(aes(col = overlap), arrow = arrow(length = unit(4, 'mm'), type = \"closed\"), \n                start_cap = circle(3, 'mm'),\n                end_cap = circle(3, 'mm')) + \n  geom_node_point(size = 4) + \n  geom_node_label(aes(label = name), repel = TRUE, alpha = 0.7) +\n  facet_edges(~ levels, ncol = 2) + \n  theme_light() +\n  scale_edge_color_gradient(low = \"blue\", high = \"red\")\n```\n:::\n\n\n\n-->\n  \n## Overlap between a home range and a simple feature\n\nThe function `hr_overlap_feature` allows to calculate percentage overlap ($HR$ index) between a home. To illustrate this feature, we will use again the data from `lupe` and calculate the intersection with an arbitrary polygon. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoly <- amt::bbox(lupe, buffer = -500, sf = TRUE)\npoly1 <- amt::bbox(lupe, sf = TRUE)\nhr <- hr_mcp(lupe)\nggplot() + geom_sf(data = hr_isopleths(hr)) + \n  geom_sf(data = poly, fill = NA, col = \"red\") +\n  geom_sf(data = poly1, fill = NA, col = \"blue\")\n```\n\n::: {.cell-output-display}\n![](amt_hr_overlap_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_overlap_feature(hr, poly, direction = \"hr_with_feature\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n   from    to overlap\n  <dbl> <int>   <dbl>\n1  0.95     1   0.828\n```\n\n\n:::\n\n```{.r .cell-code}\nhr_overlap_feature(hr, poly1, direction = \"hr_with_feature\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n   from    to overlap\n  <dbl> <int>   <dbl>\n1  0.95     1    1.00\n```\n\n\n:::\n\n```{.r .cell-code}\nhr_overlap_feature(hr, poly, direction = \"feature_with_hr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n   from    to overlap\n  <int> <dbl>   <dbl>\n1     1  0.95   0.854\n```\n\n\n:::\n\n```{.r .cell-code}\nhr_overlap_feature(hr, poly1, direction = \"feature_with_hr\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n   from    to overlap\n  <int> <dbl>   <dbl>\n1     1  0.95   0.542\n```\n\n\n:::\n:::\n\n\n\n\nThe same work with several home-range levels:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr <- hr_mcp(lupe, levels = c(0.5, 0.9, 0.95))\nhr_overlap_feature(hr, poly, direction = \"hr_with_feature\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n   from    to overlap\n  <dbl> <int>   <dbl>\n1  0.5      1   0.828\n2  0.9      1   0.860\n3  0.95     1   0.990\n```\n\n\n:::\n:::\n\n\n\n\n\n## References\n- Fieberg, J., & Kochanny, C. O. (2005). Quantifying home‐range overlap: the importance of the utilization distribution. The Journal of Wildlife Management, 69(4), 1346-1359.\n\n\n## Session\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.1 (2024-06-14 ucrt)\n os       Windows 11 x64 (build 22631)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Denver\n date     2024-10-17\n pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package      * version  date (UTC) lib source\n amt          * 0.2.2.0  2024-04-01 [1] CRAN (R 4.4.1)\n backports      1.5.0    2024-05-23 [1] CRAN (R 4.4.0)\n cachem         1.1.0    2024-05-16 [1] CRAN (R 4.4.1)\n checkmate      2.3.1    2023-12-04 [1] CRAN (R 4.4.1)\n class          7.3-22   2023-05-03 [1] CRAN (R 4.4.1)\n classInt       0.4-10   2023-09-05 [1] CRAN (R 4.4.1)\n cli            3.6.2    2023-12-11 [1] CRAN (R 4.4.0)\n codetools      0.2-20   2024-03-31 [1] CRAN (R 4.4.1)\n colorspace     2.1-0    2023-01-23 [1] CRAN (R 4.4.0)\n DBI            1.2.3    2024-06-02 [1] CRAN (R 4.4.1)\n digest         0.6.36   2024-06-23 [1] CRAN (R 4.4.1)\n dplyr          1.1.4    2023-11-17 [1] CRAN (R 4.4.1)\n e1071          1.7-14   2023-12-06 [1] CRAN (R 4.4.1)\n evaluate       0.24.0   2024-06-10 [1] CRAN (R 4.4.1)\n fansi          1.0.6    2023-12-08 [1] CRAN (R 4.4.0)\n farver         2.1.2    2024-05-13 [1] CRAN (R 4.4.0)\n fastmap        1.2.0    2024-05-15 [1] CRAN (R 4.4.1)\n generics       0.1.3    2022-07-05 [1] CRAN (R 4.4.0)\n ggforce        0.4.2    2024-02-19 [1] CRAN (R 4.4.1)\n ggplot2      * 3.5.1    2024-04-23 [1] CRAN (R 4.4.0)\n ggraph       * 2.2.1    2024-03-07 [1] CRAN (R 4.4.1)\n ggrepel        0.9.5    2024-01-10 [1] CRAN (R 4.4.1)\n glue           1.7.0    2024-01-09 [1] CRAN (R 4.4.0)\n graphlayouts   1.2.0    2024-09-24 [1] CRAN (R 4.4.1)\n gridExtra      2.3      2017-09-09 [1] CRAN (R 4.4.0)\n gtable         0.3.5    2024-04-22 [1] CRAN (R 4.4.0)\n htmltools      0.5.8.1  2024-04-04 [1] CRAN (R 4.4.1)\n htmlwidgets    1.6.4    2023-12-06 [1] CRAN (R 4.4.1)\n igraph         2.0.3    2024-03-13 [1] CRAN (R 4.4.1)\n jsonlite       1.8.8    2023-12-04 [1] CRAN (R 4.4.1)\n KernSmooth     2.23-24  2024-05-17 [1] CRAN (R 4.4.1)\n knitr          1.47     2024-05-29 [1] CRAN (R 4.4.1)\n lattice        0.22-6   2024-03-20 [1] CRAN (R 4.4.1)\n lifecycle      1.0.4    2023-11-07 [1] CRAN (R 4.4.0)\n lubridate      1.9.3    2023-09-27 [1] CRAN (R 4.4.0)\n magrittr       2.0.3    2022-03-30 [1] CRAN (R 4.4.0)\n MASS           7.3-60.2 2024-04-26 [1] CRAN (R 4.4.1)\n Matrix         1.7-0    2024-04-26 [1] CRAN (R 4.4.1)\n memoise        2.0.1    2021-11-26 [1] CRAN (R 4.4.1)\n munsell        0.5.1    2024-04-01 [1] CRAN (R 4.4.0)\n pillar         1.9.0    2023-03-22 [1] CRAN (R 4.4.0)\n pkgconfig      2.0.3    2019-09-22 [1] CRAN (R 4.4.0)\n polyclip       1.10-6   2023-09-27 [1] CRAN (R 4.4.0)\n proxy          0.4-27   2022-06-09 [1] CRAN (R 4.4.1)\n purrr          1.0.2    2023-08-10 [1] CRAN (R 4.4.1)\n R6             2.5.1    2021-08-19 [1] CRAN (R 4.4.0)\n rbibutils      2.3      2024-10-04 [1] CRAN (R 4.4.1)\n Rcpp           1.0.12   2024-01-09 [1] CRAN (R 4.4.0)\n Rdpack         2.6.1    2024-08-06 [1] CRAN (R 4.4.1)\n rlang          1.1.4    2024-06-04 [1] CRAN (R 4.4.0)\n rmarkdown      2.27     2024-05-17 [1] CRAN (R 4.4.1)\n rstudioapi     0.16.0   2024-03-24 [1] CRAN (R 4.4.1)\n scales         1.3.0    2023-11-28 [1] CRAN (R 4.4.0)\n sessioninfo    1.2.2    2021-12-06 [1] CRAN (R 4.4.1)\n sf             1.0-16   2024-03-24 [1] CRAN (R 4.4.1)\n survival       3.6-4    2024-04-24 [1] CRAN (R 4.4.1)\n terra          1.7-78   2024-05-22 [1] CRAN (R 4.4.0)\n tibble         3.2.1    2023-03-20 [1] CRAN (R 4.4.0)\n tidygraph    * 1.3.1    2024-01-30 [1] CRAN (R 4.4.1)\n tidyr          1.3.1    2024-01-24 [1] CRAN (R 4.4.1)\n tidyselect     1.2.1    2024-03-11 [1] CRAN (R 4.4.1)\n timechange     0.3.0    2024-01-18 [1] CRAN (R 4.4.0)\n tweenr         2.0.3    2024-02-26 [1] CRAN (R 4.4.1)\n units          0.8-5    2023-11-28 [1] CRAN (R 4.4.1)\n utf8           1.2.4    2023-10-22 [1] CRAN (R 4.4.0)\n vctrs          0.6.5    2023-12-01 [1] CRAN (R 4.4.0)\n viridis        0.6.5    2024-01-29 [1] CRAN (R 4.4.0)\n viridisLite    0.4.2    2023-05-02 [1] CRAN (R 4.4.0)\n withr          3.0.0    2024-01-16 [1] CRAN (R 4.4.0)\n xfun           0.45     2024-06-16 [1] CRAN (R 4.4.1)\n yaml           2.3.8    2023-12-11 [1] CRAN (R 4.4.0)\n\n [1] C:/Users/C825033651/AppData/Local/Programs/R/R-4.4.1/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::",
    "supporting": [
      "amt_hr_overlap_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}