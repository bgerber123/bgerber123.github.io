{
  "hash": "b2d4525fbef7fe1fec162c1f9dd34b13",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Getting started with `amt`\"\nauthor: \"Johannes Signer\"\ndate: \"2024-10-15\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{Getting started with `amt`}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n\n## Basics\n\n### Creating a track\n\nThe basic building blocks of `amt` are tracks. Tracks are `tibble`s with at least two columns that contain the coordinates: `x_` and `y_`. A track behaves exactly like a `tibble` (the only difference being that we added an other S3 class). Below is an example of creating a track with some dummy locations.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(amt)\ndf1 <- tibble(x = 1:3, y = 1:3)\nis.data.frame(df1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ndf1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n      x     y\n  <int> <int>\n1     1     1\n2     2     2\n3     3     3\n```\n\n\n:::\n\n```{.r .cell-code}\n# Now we can create a track\ntr1 <- make_track(df1, x, y)\nis.data.frame(tr1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ntr1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n     x_    y_\n* <int> <int>\n1     1     1\n2     2     2\n3     3     3\n```\n\n\n:::\n:::\n\n\n\n\nAt the moment `amt` supports two types of tracks:\n\n- `track_xy` is a track that only has coordinates, and\n- `track_xyt` is a track that has a timestamp associated to each coordinate pair.\n\nIf a `track_xy` or `track_xyt` is created with the function `make_track`, is determined whether or not a timestamp is passed as a third argument (called `.t`) to the function `make_track`. In the previous example we only passed `x` and `y` coordinates. Hence a `track_xy` was created.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(tr1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"track_xy\"   \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\nTo create a `track_xyt` we could do the following\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- tibble(x = 1:3, y = 1:3, t = lubridate::ymd(\"2017-01-01\") + lubridate::days(0:2))\ntr2 <- make_track(df1, x, y, t)\nclass(tr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"track_xyt\"  \"track_xy\"   \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\nFrom the output above we see that a `track_xyt` is also a `track_xy`. This means that all methods for `track_xy` also work for a `track_xyt` (but not the reverse).\n\n\n### Adding additional information\n\nWe can also add additional information for each relocation (e.g., the id of the animal, or some other sensor information such as the DOP). Any number of additional named columns can be passed to `make_track`. By named we mean, that columns should always be passed in the form of `column_name = content` to avoid confusion with coordinates and time stamp. We will extend the dummy example from above, by passing 2 more columns (the id of animal and the age).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- tibble(x = 1:3, y = 1:3, t = lubridate::ymd(\"2017-01-01\") + lubridate::days(0:2), \n                  id = 1, age = 4)\n\n# first we only create a track_xy\ntr3 <- make_track(df1, x, y, id = id, age = age)\ntr3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n     x_    y_    id   age\n* <int> <int> <dbl> <dbl>\n1     1     1     1     4\n2     2     2     1     4\n3     3     3     1     4\n```\n\n\n:::\n\n```{.r .cell-code}\n# now lets create a track_xyt\ntr4 <- make_track(df1, x, y, t, id = id, age = age)\ntr4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n     x_    y_ t_            id   age\n* <int> <int> <date>     <dbl> <dbl>\n1     1     1 2017-01-01     1     4\n2     2     2 2017-01-02     1     4\n3     3     3 2017-01-03     1     4\n```\n\n\n:::\n:::\n\n\n\n\n### Coordinate reference system\n\n`make_track` has one further optional argument (`crs`), which allows the user to set a coordinate reference system (CRS) of the track. The CRS needs to be provided as valid EPSG code.\n\n### An example with one real animal\n\nIn the `amt` relocation data of one red deer from northern Germany is included. We will use this data set to to illustrate how to create a track.\n\nWe begin with loading and inspecting the data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(sh)\nhead(sh)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x_epsg31467 y_epsg31467        day     time\n1     3558403     5999400 2009-02-13 00:02:23\n2     3558548     5999099 2009-02-13 06:02:21\n3     3558541     5999019 2009-02-13 12:01:51\n4     3558453     5999026 2009-02-13 18:00:55\n5     3558566     5999365 2009-02-14 00:01:36\n6     3557836     5999185 2009-02-14 06:02:24\n```\n\n\n:::\n:::\n\n\n\n\nBefore creating a track, we have to do some data cleaning:\n\n1. check if any coordinates are missing (and if so, remove the relocation), \n2. parse the date and time, \n3. create a time stamp, \n4. check for duplicated time stamps, and\n5. create two new columns for the id and month of the year.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check if all observations are complete\nall(complete.cases(sh)) # no action required\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# parse date and time and create time stamps\nsh$ts <- as.POSIXct(lubridate::ymd(sh$day) +\n                      lubridate::hms(sh$time))\n\n# check for duplicated time stamps\nany(duplicated(sh$ts))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# We have some duplicated time stamps, these need to be removed prior to\n# creating a track.\nsh <- sh[!duplicated(sh$ts), ]\n\n# create new columns\nsh$id <- \"Animal 1\"\nsh$month <- lubridate::month(sh$ts)\n```\n:::\n\n\n\n\nNow we can create a track.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntr1 <- make_track(sh, x_epsg31467, y_epsg31467, ts, id = id, month = month)\n```\n:::\n\n\n\n\nThe column names of the data set already indicate the CRS of the data. We can add this information when creating a track.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntr1 <- make_track(sh, x_epsg31467, y_epsg31467, ts, id = id, month = month, \n                crs = 31467)\n```\n:::\n\n\n\n\n### A note on pipes (`|>`)\n`amt` was heavily inspired through workflows suggested by the popular packages from the `tidyverse`. The above steps could easily be connected using pipes. Note that result will be exactly the same.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(sh)\ntr2 <- sh |> filter(complete.cases(sh)) |> \n  mutate(\n    ts = as.POSIXct(lubridate::ymd(day) + lubridate::hms(time)), \n    id = \"Animal 1\", \n    month = lubridate::month(ts)\n  ) |> \n  filter(!duplicated(ts)) |> \n  make_track(x_epsg31467, y_epsg31467, ts, id = id, month = month, \n           crs = 31467)\ntr2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,493 × 5\n        x_      y_ t_                  id       month\n *   <int>   <int> <dttm>              <chr>    <dbl>\n 1 3558528 5999094 2008-03-30 00:01:47 Animal 1     3\n 2 3558513 5999055 2008-03-30 06:00:54 Animal 1     3\n 3 3558564 5999146 2008-03-30 12:01:47 Animal 1     3\n 4 3558504 5999072 2008-03-30 18:01:24 Animal 1     3\n 5 3558495 5999051 2008-03-30 18:25:56 Animal 1     3\n 6 3558493 5999052 2008-03-30 18:26:05 Animal 1     3\n 7 3558489 5999051 2008-03-30 18:26:14 Animal 1     3\n 8 3558486 5999046 2008-03-30 18:26:24 Animal 1     3\n 9 3558484 5999052 2008-03-30 18:26:33 Animal 1     3\n10 3558317 5998989 2008-03-30 18:38:01 Animal 1     3\n# ℹ 1,483 more rows\n```\n\n\n:::\n:::\n\n\n\n\n## Working with tracks\n\n### Utility functions\n#### Basic manipulation\n\nRemember, that a `track_xy*` behaves like regular a `data.frame`. This means that we can use all data manipulation verbs that we are used to from `base` R or the `tidyverse`. For example, we can filter a track based on some characteristic. As an example we extract all relocations from the month May. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntr3 <- tr2 |> filter(month == 5)\n\n# we are left with a track\nclass(tr3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"track_xyt\"  \"track_xy\"   \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n\n#### Transforming CRS\n\nIf we set the CRS when creating a track (we can verify this with `has_crs`), we can transform the CRS of the coordinates with the function `transform_coords` (a wrapper around `sf::st_transform()`). For illustration, we will transform the CRS of `tr2` to geographical coordinates (EPSG:4326).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransform_coords(tr2, 4326)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,493 × 5\n      x_    y_ t_                  id       month\n * <dbl> <dbl> <dttm>              <chr>    <dbl>\n 1  9.89  54.1 2008-03-30 00:01:47 Animal 1     3\n 2  9.89  54.1 2008-03-30 06:00:54 Animal 1     3\n 3  9.89  54.1 2008-03-30 12:01:47 Animal 1     3\n 4  9.89  54.1 2008-03-30 18:01:24 Animal 1     3\n 5  9.89  54.1 2008-03-30 18:25:56 Animal 1     3\n 6  9.89  54.1 2008-03-30 18:26:05 Animal 1     3\n 7  9.89  54.1 2008-03-30 18:26:14 Animal 1     3\n 8  9.89  54.1 2008-03-30 18:26:24 Animal 1     3\n 9  9.89  54.1 2008-03-30 18:26:33 Animal 1     3\n10  9.89  54.1 2008-03-30 18:38:01 Animal 1     3\n# ℹ 1,483 more rows\n```\n\n\n:::\n:::\n\n\n\n\n### Some initial data exploration\n\nSeveral functions for calculating derived quantities are available. We will start with looking at step length. The function `step_lengths` can be used for this.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntr2 <- tr2 |> mutate(sl_ = step_lengths(tr2))\n```\n:::\n\n\n\n\nIf we look at a summary of `sl_` we note two things:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(tr2$sl_)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00   35.01  105.33  249.07  297.75 4727.86       1 \n```\n\n\n:::\n:::\n\n\n\n\nNote, 1) there is a `NA` for the last step length, this is expected because we are still in a point representation (i.e., there is no step length for the last relocation). 2) the range is fairly large ranging from 0 to almost 5 km. Before looking at step lengths in any further detail, we will have to make sure the sampling rate is more or less regular (i.e., the same time step between any two points).\n\nThe function `summarize_sampling_rate` provides an easy way to look at the sampling rate.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize_sampling_rate(tr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 9\n     min    q1 median  mean    q3   max    sd     n unit \n   <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <int> <chr>\n1 0.0025  2.00   2.01  6.34  6.00 3924.  102.  1492 hour \n```\n\n\n:::\n:::\n\n\n\n\nThis suggests that a sampling rate for 6 hours might be adequate. We can then use the function `track_resample` to resample the track and only keep relocations that are approximately 6 hours apart (within some tolerance, that can be specified). We will use the function `lubridate::hours` to specify the sampling rate and `lubridate::minutes` to specify the tolerance. Both arguments `rate` and `tolerance` are expected to be a `Period`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntr3 <- tr2 |> track_resample(rate = hours(6), tolerance = minutes(20))\ntr3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 826 × 7\n        x_      y_ t_                  id       month    sl_ burst_\n *   <int>   <int> <dttm>              <chr>    <dbl>  <dbl>  <dbl>\n 1 3558528 5999094 2008-03-30 00:01:47 Animal 1     3  41.8       1\n 2 3558513 5999055 2008-03-30 06:00:54 Animal 1     3 104.        1\n 3 3558564 5999146 2008-03-30 12:01:47 Animal 1     3  95.3       1\n 4 3558504 5999072 2008-03-30 18:01:24 Animal 1     3  22.8       1\n 5 3557474 5999130 2008-03-31 00:01:23 Animal 1     3 155.        1\n 6 3557319 5999127 2008-03-31 06:01:45 Animal 1     3   6.08      1\n 7 3557313 5999126 2008-03-31 12:01:11 Animal 1     3   4.47      1\n 8 3557317 5999128 2008-03-31 18:01:55 Animal 1     3 113.        1\n 9 3557204 5999130 2008-04-01 00:01:24 Animal 1     4 187.        1\n10 3557108 5999291 2008-04-01 06:00:54 Animal 1     4   6.32      1\n# ℹ 816 more rows\n```\n\n\n:::\n:::\n\n\n\n\n`tr3` still a track, but with two differences compared to `tr2`. 1) the number of rows is reduced from 1493 to 826, because only relocations that are 6 hours +/- the tolerance apart of each other are retained; 2) `tr3` has one new column called `burst_`. A burst is sequence of relocations with equal sampling rates. Consider the following hypothetical example: 5 relocations are all 6 hours apart. Then there is a gap of 12 hours because one relocation failed and afterwards then there are an other 10 relocations all 6 hours apart. Then we would consider the first 5 relocations as a burst and the second 10 relocations (after the 12 hour gap) as a second burst.\n\n\n\n### From tracks to steps\n\nIn many situations we are more interested in steps (that is the animal moving from one relocation to an other, or the straight line between a start and a end point), that in the individual relocations. `amt` supports `steps` as an other way to represent movement data. The transition from a track to steps can be done via two functions.\n\n1. `steps()`: Takes as an input a track, converts the track to step and calculating some derived quantities (e.g., step lengths, turning angles). The function `steps()` expects a track with regular sampling rates.\n2. `steps_by_burst()`: Takes as an input a resampled track (i.e., a track with several bursts) and will calculate derived quantities per burst.\n\n\n\n## How to deal with several animals\n\nUp to now we have only considered situations with one animal. However, in most telemetry studies more than one animal are tracked and we often want to calculated movement relevant characteristics for several animals individually. `amt` does not provide a infrastructure for dealing with several animal, however, `list`-columns from the `tidyverse` can be used to manage many animals. Because a track is just a `tibble` all `tidyverse` verbs can be used. The general strategy consists of three steps:\n\n1. Nest a track by one or more columns. This retains the unique values of the grouping variable(s) and creates a new `list`-column with tracks. \n2. Now we can perform operations on the grouped data creating a new list column. This can be done in a combination with `mutate` and `map` (instead of `map` also `lapply` could be used). \n3. Select the relevant columns and unnest. With `select()` we can select columns of interest and reverse the nesting with the function `unnest()`.\n\nAs an example we will use a second data set included in `amt` on tracks of four fishers. We will load the data, create a track, resample the tracks individually to 30 min and create a histogram of step lengths (accounting for bursts).\n\nWe start by loading the data and creating a track of all individuals together\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"amt_fisher\")\ntrk <- amt_fisher |> make_track(x_, y_, t_, id = id)\n```\n:::\n\n\n\n\nNext, we group the track by `id` and nest the track.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrk1 <- trk |> nest(data = -\"id\")\ntrk1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  id    data                  \n  <chr> <list>                \n1 M1    <trck_xyt [919 × 3]>  \n2 M4    <trck_xyt [8,958 × 3]>\n3 F2    <trck_xyt [3,004 × 3]>\n4 F1    <trck_xyt [1,349 × 3]>\n```\n\n\n:::\n:::\n\n\n\n\nWe now want to resample each track to 30 minutes with a tolerance of 5 minutes and create steps for each animal. For the first animal we would do as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the data for the first animal\nx <- trk1$data[[1]]\n\n# apply the data analysis\nx |> track_resample(rate = minutes(30), tolerance = minutes(5)) |>\n  steps_by_burst()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 412 × 11\n   burst_      x1_      x2_      y1_      y2_   sl_ direction_p   ta_\n *  <dbl>    <dbl>    <dbl>    <dbl>    <dbl> <dbl>       <dbl> <dbl>\n 1      1 1782673. 1782683. 2402297. 2402292. 10.6       -0.427 NA   \n 2      1 1782683. 1782681. 2402292. 2402297.  4.96       2.08   2.51\n 3      1 1782681. 1782683. 2402297. 2402298.  2.19       0.464 -1.62\n 4      1 1782683. 1782682. 2402298. 2402290.  7.50      -1.68  -2.15\n 5      1 1782682. 1782684. 2402290. 2402298.  8.01       1.24   2.92\n 6      1 1782684. 1782685. 2402298. 2402274. 24.2       -1.54  -2.78\n 7      1 1782685. 1782669. 2402274. 2402309. 38.8        1.98  -2.76\n 8      1 1782669. 1782679. 2402309. 2402299. 13.6       -0.825 -2.80\n 9      1 1782679. 1782679. 2402299. 2402304.  5.26       1.52   2.34\n10      1 1782679. 1782699. 2402304. 2402273. 37.2       -1.00  -2.52\n# ℹ 402 more rows\n# ℹ 3 more variables: t1_ <dttm>, t2_ <dttm>, dt_ <drtn>\n```\n\n\n:::\n:::\n\n\n\n\nWe now want to apply exactly the same logic to all animals. We can do this by using a `map` and save the results to a new column using `mutate`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrk2 <- trk1 |> \n  mutate(steps = map(data, function(x) \n    x |> track_resample(rate = minutes(30), tolerance = minutes(5)) |> steps_by_burst()))\n\ntrk2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  id    data                   steps                \n  <chr> <list>                 <list>               \n1 M1    <trck_xyt [919 × 3]>   <brstd_s_ [412 × 11]>\n2 M4    <trck_xyt [8,958 × 3]> <brstd_s_ [850 × 11]>\n3 F2    <trck_xyt [3,004 × 3]> <brstd_s_ [308 × 11]>\n4 F1    <trck_xyt [1,349 × 3]> <brstd_s_ [413 × 11]>\n```\n\n\n:::\n:::\n\n\n\n\nFinally, we can select `id` and `steps`, unnest the new `data_frame` and create a plot of the step-length distributions.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrk2 |> select(id, steps) |> unnest(cols = steps) |> \n  ggplot(aes(sl_, fill = factor(id))) + geom_density(alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](p1_getting_started_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n## Session\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.1 (2024-06-14 ucrt)\n os       Windows 11 x64 (build 22631)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Denver\n date     2024-10-15\n pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n amt         * 0.2.2.0 2024-04-01 [1] CRAN (R 4.4.1)\n backports     1.5.0   2024-05-23 [1] CRAN (R 4.4.0)\n checkmate     2.3.1   2023-12-04 [1] CRAN (R 4.4.1)\n class         7.3-22  2023-05-03 [1] CRAN (R 4.4.1)\n classInt      0.4-10  2023-09-05 [1] CRAN (R 4.4.1)\n cli           3.6.2   2023-12-11 [1] CRAN (R 4.4.0)\n colorspace    2.1-0   2023-01-23 [1] CRAN (R 4.4.0)\n data.table    1.15.4  2024-03-30 [1] CRAN (R 4.4.0)\n DBI           1.2.3   2024-06-02 [1] CRAN (R 4.4.1)\n digest        0.6.36  2024-06-23 [1] CRAN (R 4.4.1)\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.4.1)\n e1071         1.7-14  2023-12-06 [1] CRAN (R 4.4.1)\n evaluate      0.24.0  2024-06-10 [1] CRAN (R 4.4.1)\n fansi         1.0.6   2023-12-08 [1] CRAN (R 4.4.0)\n farver        2.1.2   2024-05-13 [1] CRAN (R 4.4.0)\n fastmap       1.2.0   2024-05-15 [1] CRAN (R 4.4.1)\n generics      0.1.3   2022-07-05 [1] CRAN (R 4.4.0)\n ggplot2     * 3.5.1   2024-04-23 [1] CRAN (R 4.4.0)\n glue          1.7.0   2024-01-09 [1] CRAN (R 4.4.0)\n gtable        0.3.5   2024-04-22 [1] CRAN (R 4.4.0)\n htmltools     0.5.8.1 2024-04-04 [1] CRAN (R 4.4.1)\n htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.4.1)\n jsonlite      1.8.8   2023-12-04 [1] CRAN (R 4.4.1)\n KernSmooth    2.23-24 2024-05-17 [1] CRAN (R 4.4.1)\n knitr         1.47    2024-05-29 [1] CRAN (R 4.4.1)\n labeling      0.4.3   2023-08-29 [1] CRAN (R 4.4.0)\n lattice       0.22-6  2024-03-20 [1] CRAN (R 4.4.1)\n lifecycle     1.0.4   2023-11-07 [1] CRAN (R 4.4.0)\n lubridate     1.9.3   2023-09-27 [1] CRAN (R 4.4.0)\n magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.4.0)\n Matrix        1.7-0   2024-04-26 [1] CRAN (R 4.4.1)\n munsell       0.5.1   2024-04-01 [1] CRAN (R 4.4.0)\n pillar        1.9.0   2023-03-22 [1] CRAN (R 4.4.0)\n pkgconfig     2.0.3   2019-09-22 [1] CRAN (R 4.4.0)\n proxy         0.4-27  2022-06-09 [1] CRAN (R 4.4.1)\n purrr         1.0.2   2023-08-10 [1] CRAN (R 4.4.1)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.4.0)\n rbibutils     2.3     2024-10-04 [1] CRAN (R 4.4.1)\n Rcpp          1.0.12  2024-01-09 [1] CRAN (R 4.4.0)\n Rdpack        2.6.1   2024-08-06 [1] CRAN (R 4.4.1)\n rlang         1.1.4   2024-06-04 [1] CRAN (R 4.4.0)\n rmarkdown     2.27    2024-05-17 [1] CRAN (R 4.4.1)\n rstudioapi    0.16.0  2024-03-24 [1] CRAN (R 4.4.1)\n scales        1.3.0   2023-11-28 [1] CRAN (R 4.4.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.4.1)\n sf            1.0-16  2024-03-24 [1] CRAN (R 4.4.1)\n survival      3.6-4   2024-04-24 [1] CRAN (R 4.4.1)\n tibble        3.2.1   2023-03-20 [1] CRAN (R 4.4.0)\n tidyr         1.3.1   2024-01-24 [1] CRAN (R 4.4.1)\n tidyselect    1.2.1   2024-03-11 [1] CRAN (R 4.4.1)\n timechange    0.3.0   2024-01-18 [1] CRAN (R 4.4.0)\n units         0.8-5   2023-11-28 [1] CRAN (R 4.4.1)\n utf8          1.2.4   2023-10-22 [1] CRAN (R 4.4.0)\n vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.4.0)\n withr         3.0.0   2024-01-16 [1] CRAN (R 4.4.0)\n xfun          0.45    2024-06-16 [1] CRAN (R 4.4.1)\n yaml          2.3.8   2023-12-11 [1] CRAN (R 4.4.0)\n\n [1] C:/Users/C825033651/AppData/Local/Programs/R/R-4.4.1/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::",
    "supporting": [
      "p1_getting_started_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}