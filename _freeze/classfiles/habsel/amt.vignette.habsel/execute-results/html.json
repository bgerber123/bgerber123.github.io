{
  "hash": "922314e89e58dc14ddfb6cddab7c5368",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Resource Selection Functions (RSF) with `amt`\"\nauthor: \"Johannes Signer\"\ndate: \"2024-10-17\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteKeyword{rsf}\n  %\\VignetteIndexEntry{Resource Selection Functions (RSF) with `amt`}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n\n\n\n\n## About\n\nThis vignette briefly introduces how one can fit a Resource-Selection Function (RSF) with the `amt` package. We will be using the example data of one red deer from northern Germany and one covariate: a forest cover map.\n\n## Getting the data ready\n\nFirst we load the required libraries and the relocation data (called `deer`)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(amt)\ndata(\"deer\")\ndeer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 826 × 4\n         x_       y_ t_                  burst_\n *    <dbl>    <dbl> <dttm>               <dbl>\n 1 4314068. 3445807. 2008-03-30 00:01:47      1\n 2 4314053. 3445768. 2008-03-30 06:00:54      1\n 3 4314105. 3445859. 2008-03-30 12:01:47      1\n 4 4314044. 3445785. 2008-03-30 18:01:24      1\n 5 4313015. 3445858. 2008-03-31 00:01:23      1\n 6 4312860. 3445857. 2008-03-31 06:01:45      1\n 7 4312854. 3445856. 2008-03-31 12:01:11      1\n 8 4312858. 3445858. 2008-03-31 18:01:55      1\n 9 4312745. 3445862. 2008-04-01 00:01:24      1\n10 4312651. 3446024. 2008-04-01 06:00:54      1\n# ℹ 816 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\nNext, we have to get the environmental covariates. A forest layer is included in the package. Note, that this a regular `SpatRast`. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsh_forest <- get_sh_forest()\n```\n:::\n\n\n\n\n## Prepare Data for RSF\n\n### Random Points\n\nBefore fitting a RSF we have to do some data preparation. We have to generate random points, points that we think the animal could have used. The random points define the availability domain. In `amt` the function `random_points` is designed to do just that. The function can be used in 3 different ways, depending to the type of object that is passed to the function call. \n\n1. A `track_*` (such as the `deer` object) can be passed to the function `random_points`. The function then calculates a home range (the home-range estimator can be controlled with argument `hr`). Within this home range `n` random points are generated. The default value of `n` is ten times the number of present points.\n2. If a `hr`-object (i.e., the result of a home-range estimation in `amt`) is passed to `random_points`, points are generated within the home range. This allows to generate random points within any home range that was previously estimated in `amt`. Note, that this could be a home range of multiple animals. In this case, the function `random_points` has one additional argument called `presence`. This argument takes a `trk_*` with the presence points and adds these points for convenience to the random points. \n3. A `SpatialPolygons*`-object or `sf`-object. The latter must contain `POLYGON`s or `MULTIPOLYGON`s as features. This can be useful in situation where a home range needs to be buffered, or when other geographical features are considered as the availability domain. As before, this method for `random_points` also takes the argument `presence` to optionally add the observed points to the output.\n\nLets now illustrate the three different situations. First we take random points from a `track_xy`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr1 <- random_points(deer)\nplot(r1)\n```\n\n::: {.cell-output-display}\n![](amt.vignette.habsel_files/figure-html/unnamed-chunk-4-1.png){width=384}\n:::\n:::\n\n\n\n\nWith the argument `n` we can control the number of random points (remember that the default is ten times as many points as we observed points). \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr1 <- random_points(deer, n = 100)\nplot(r1)\n```\n\n::: {.cell-output-display}\n![](amt.vignette.habsel_files/figure-html/unnamed-chunk-5-1.png){width=384}\n:::\n:::\n\n\n\n\nNext, we can create random point within a home range, that we estimated before. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr <- hr_mcp(deer)\nr1 <- random_points(hr, n = 500)\nplot(r1)\n```\n\n::: {.cell-output-display}\n![](amt.vignette.habsel_files/figure-html/unnamed-chunk-6-1.png){width=384}\n:::\n:::\n\n\n\n\nHere, we can also add the observed points: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr <- hr_mcp(deer)\nr1 <- random_points(hr, n = 500, presence = deer)\nplot(r1)\n```\n\n::: {.cell-output-display}\n![](amt.vignette.habsel_files/figure-html/unnamed-chunk-7-1.png){width=384}\n:::\n:::\n\n\n\n\nFinally, we can work with the home range and for example a buffer and then generate random points within the this new polygon. \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr <- hr_mcp(deer) |> hr_isopleths() |> \n  sf::st_buffer(dist =3e4) # add a 30km buffer\nr1 <- random_points(hr, n = 500)\nplot(r1)\n```\n\n::: {.cell-output-display}\n![](amt.vignette.habsel_files/figure-html/unnamed-chunk-8-1.png){width=384}\n:::\n:::\n\n\n\n\nAnd we can also add the observed points.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr <- hr_mcp(deer) |> hr_isopleths() |> \n  sf::st_buffer(dist =3e4) # add a 30km buffer\nr1 <- random_points(hr, n = 500, presence = deer)\nplot(r1)\n```\n\n::: {.cell-output-display}\n![](amt.vignette.habsel_files/figure-html/unnamed-chunk-9-1.png){width=384}\n:::\n:::\n\n\n\n\n\n\nOf course we are not restricted to the `sf::st_buffer` function. All geometric operations from the `sf` package can be used to generate arbitrarily complex availability domains. \n\n\n### Extract covariates\n\nAs the next step we have to extract the covariates at point. We can do this with `extract_covariates`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrsf1 <- deer |> random_points() |> \n  extract_covariates(sh_forest) \n```\n:::\n\n\n\n\n\n## Fitting RSF\n\nNow all pieces are there to fit a RSF. We will use `fit_rsf`, which is just a wrapper around `stats::glm` with `family = binomial(link = \"logit\")`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrsf1 |> fit_rsf(case_ ~ forest) |> \n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nstats::glm(formula = formula, family = stats::binomial(link = \"logit\"), \n    data = data)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept) -2.45592    0.04403 -55.775  < 2e-16 ***\nforest       0.58238    0.07922   7.352 1.96e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5535.8  on 9085  degrees of freedom\nResidual deviance: 5485.0  on 9084  degrees of freedom\nAIC: 5489\n\nNumber of Fisher Scoring iterations: 5\n```\n\n\n:::\n:::\n",
    "supporting": [
      "amt.vignette.habsel_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}