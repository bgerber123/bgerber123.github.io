{
  "hash": "057cb3b85f579f6a0412ab61261d1376",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Survival Estimation with Capture-Recapture Data\"\noutput: html_document\n---\n\n\n<style type=\"text/css\">\n\nbody, td {\n   font-size: 16px;\n}\ncode.r{\n  font-size: 18px;\n}\npre {\n  font-size: 18px\n}\n</style>\n\n\n\n\n\n\n# The Setup\n\nWe will estimate the annual survival probability of European Dipper using capture-recapture data \nvia a hierarchical Bayesian version of the cormack-jolly-seber model.\n\nLoad the necessary packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  library(stringr)\n  library(rjags)\n  library(coda)\n```\n:::\n\n\nNext, read in the data. The first column is the capture-history. The second column indicates males (0) and females (1). The third column indicate females (1) and males (0). The fourth column are just semi-colons...it's MARK thing. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Load the Data\n  dipper = read.table(\"DIPPER.INP\", skip = 2,sep=\"\", colClasses = \"character\")\n  head(dipper)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1 V2 V3 V4\n1 1111110  1  0  ;\n2 1111100  0  1  ;\n3 1111000  1  0  ;\n4 1111000  0  1  ;\n5 1101110  0  1  ;\n6 1100000  1  0  ;\n```\n\n\n:::\n\n```{.r .cell-code}\n#The number of individuals marked\n  nrow(dipper)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 294\n```\n\n\n:::\n:::\n\n\nNext, lets manipulate the inputted data to create capture-histories in columns, which we will use to fit our model. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# split column 1 into columns\n  CH = matrix(as.integer(str_split_fixed(dipper[,1],\"\",7)),nrow=nrow(dipper))\n  head(CH)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n[1,]    1    1    1    1    1    1    0\n[2,]    1    1    1    1    1    0    0\n[3,]    1    1    1    1    0    0    0\n[4,]    1    1    1    1    0    0    0\n[5,]    1    1    0    1    1    1    0\n[6,]    1    1    0    0    0    0    0\n```\n\n\n:::\n\n```{.r .cell-code}\n#  Sex variable: female = 1; male = 0\n  sex = as.integer(dipper$V3)\n```\n:::\n\n\nWe can see that there are 7 columns in the capture-history, 1 for each year. So, this study has 7 years of data total. \n\nNext, we need to setup two specialized functions. 'get.first' will identify the first occasion each individual was initially captured. The next function will use the capture history to create logical designations of when we know individuals are alive to be used to initialize the state parameter z.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create vector with occasion of marking for each individual (row of CH)\n  get.first <- function(x) min(which(x!=0))\n  f <- apply(CH, 1, get.first)\n\n  z.init <- matrix(NA, nrow = nrow(CH), ncol = ncol(CH))\n  for(i in 1:dim(z.init)[1]){\n    z.init[i, f[i]:dim(z.init)[2]] <- 1\n    z.init[i,f[i]] <- NA\n  }\n```\n:::\n\n\n\n# Lab Assignment  \n\n## Step 1    \n\nFit a CJS survival model that includes a sex effect on survival probability.\nAdapt the jags model code in the other file and implementation code that is above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# MCMC settings\n  ni <- 15000 # number of iterations\n  nt <- 2     # number of iterations to thin by\n  nb <- 5000  # number of iterations to burn (to toss out initially)\n  na <- 2000  # number of iterations to use to adapt to sample efficiently\n  nc <- 3     # number of chains\n\n\n# Parameters monitored\n  parameters <- c(\"beta0\",\"beta1\", \"p\")\n  \n  inits <- function(){list(beta0 = rnorm(1),\n                           beta1 = rnorm(1),\n                           p = runif(1, 0, 1), \n                           z = z.init)}\n  \n# Bundle data\n  jags.data <- list(y = CH, f = f, nind = dim(CH)[1], n.occasions = dim(CH)[2],\n                    sex=sex)\n  \n# Setup the Model\n  jm <- jags.model(file=\"cjs2.r\", data=jags.data,n.chains=nc,n.adapt=na,inits=inits)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCompiling model graph\n   Resolving undeclared variables\n   Allocating nodes\nGraph information:\n   Observed stochastic nodes: 848\n   Unobserved stochastic nodes: 851\n   Total graph size: 4950\n\nInitializing model\n```\n\n\n:::\n\n```{.r .cell-code}\n# Update the model with the burnin\n  update(jm, n.iter=nb)\n  \n#Fit the model\n  post2 <- coda.samples(jm, variable.names=parameters, n.iter=ni, thin=nt)\n  \n#Look at the results\n  summary(post2)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nIterations = 7002:22000\nThinning interval = 2 \nNumber of chains = 3 \nSample size per chain = 7500 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n          Mean      SD  Naive SE Time-series SE\nbeta0  0.28613 0.14316 0.0009544      0.0015897\nbeta1 -0.07281 0.19453 0.0012969      0.0020880\np      0.89578 0.02908 0.0001939      0.0003323\n\n2. Quantiles for each variable:\n\n          2.5%     25%      50%     75%  97.5%\nbeta0  0.00734  0.1881  0.28634 0.38261 0.5700\nbeta1 -0.45277 -0.2024 -0.07386 0.05708 0.3125\np      0.83343  0.8776  0.89804 0.91661 0.9454\n```\n\n\n:::\n:::\n\n\n\nThe summary output shows us the quantiles of each model paramter that was defined in the variable `parameters`.\n\n## Step 2\n\nCheck that parameters have converged. Show evidence of this by plotting and calculating\nthe gelman-rubin convergence diagnostic, i.e, function gelman.diag.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  plot(post2)\n```\n\n::: {.cell-output-display}\n![](cjslab.BDG_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\n  gelman.diag(post2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPotential scale reduction factors:\n\n      Point est. Upper C.I.\nbeta0          1          1\nbeta1          1          1\np              1          1\n\nMultivariate psrf\n\n1\n```\n\n\n:::\n:::\n\n\n\nWe see the diagnostic statistic (gelman-rubin statistics; known as $\\hat{R}$) are at 1, indicating no sign of lack of convergence. Also, the posterior distribution traceplots look like fuzzy caterpillars and are overlapping, also demonstrating no signs of convergence issues. \n\n# Step 3\n\nUse the estimated posterior parameters of survival to derive the posterior distributions \nfor the probability of survival for males and females. Visualize these distributions on the same plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  beta0 = post2[[1]][,1]\n  beta1 = post2[[1]][,2]\n  \n  # Posteriors of survival of males and females  \n  male.survival = plogis(beta0+beta1)\n  female.survival = plogis(beta0)\n  \n  # Plot posteriors  \n  plot(density(male.survival),lwd=3,col=1,\"Annual Survival\")\n  lines(density(female.survival),lwd=3,col=2)  \n  legend(\"topright\",lwd=3,col=c(1,2),legend=c(\"Male\",\"Female\"))\n```\n\n::: {.cell-output-display}\n![](cjslab.BDG_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nHere we see the posterior distributions of male and female annual survival. They are similar, indicating only a possible small differences in survival between the sexes.\n\n# Step 4\n\nUse Monte Carlo integration on the sex effect parameter to estimate the probability that the \nthe effect difference of male survival is less than female survival\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The probability of a sex effect- that male survival is less than female survival\n# To evaluate this, we want to know if beta1 is negative  \nlength(which(beta1<0))/length(beta1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6428\n```\n\n\n:::\n:::\n\n\nThe probability that $\\beta_1 < 0$ indicates there is no evidence of a difference. A high probability, values near 1, would indicate a stististical clear negative effect. However, if we saw probabilities near 0, this would indicate a clear statistical positive effect difference between male and female survival probability.\n\n<br>\n<br>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}